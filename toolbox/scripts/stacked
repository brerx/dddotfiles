#!/usr/bin/env ruby
# frozen_string_literal: true

require 'date'
require 'English'
require 'yaml'

# Why not using git rebase --update-refs:
# git rebase --update-refs is only possible when updating always the base branch of the stack, not for anyone in the middle, see below
# Scenario: 4 branches, A, B, C, D
# If C has been updated and the following is run:
# git checkout D
# git rebase A --update-refs is run
# --> nothing happens, because D is already on top of A, any updated branch in-between is ignored

USE_ONTO = true

class String
  def accent
    "\e[0;94m#{self}\e[0;34m"
  end
end

module Logger
  @level = 0

  def self.log(message)
    prefix = @level.zero? ? "\e[1;34m\u276f " : ''
    message = message.rjust(message.length + 2 * @level)
    puts "#{prefix}\e[0;34m#{message}\e[0m"
    write_log_file(message)

    return unless block_given?

    @level += 1
    yield
    @level -= 1
    @level = 0 if @level.negative?
  end

  def self.success(message)
    prefix = @level.zero? ? "\e[1;36m\u276f " : ''
    message = message.rjust(message.length + 2 * @level)
    puts "#{prefix}\e[0;36m#{message}\e[0m"
    write_log_file(message)
  end

  def self.error(message)
    prefix = @level.zero? ? "\e[1;31m\u276f " : ''
    message = message.rjust(message.length + 2 * @level)
    puts "#{prefix}\e[0;31m#{message}\e[0m"
    write_log_file(`Error: #{message}`)
  end

  def self.init
    `mkdir -p #{ENV['HOME']}/.dotfiles-local/stacked-log`

    current_dir = Dir.pwd.split('/').last
    @log_path = "#{ENV['HOME']}/.dotfiles-local/stacked-log/#{current_dir}.log"
  end

  def self.write_log_file(message)
    current_datetime = DateTime.now.iso8601
    File.open(@log_path, 'a') { |f| f.puts "#{current_datetime} #{message.gsub(/\e\[.*?m/, '')}" }
  end
end

module OS
  def self.mac?
    (/darwin/ =~ RUBY_PLATFORM) != nil
  end

  def self.linux?
    (/linux/ =~ RUBY_PLATFORM) != nil
  end
end

class RebaseError < StandardError
  def initialize(branch)
    super("Rebase failed for #{branch}")
  end
end

class FastForwardError < StandardError
  def initialize(branch)
    super("Fast-forward merge failed for #{branch}")
  end
end

class CheckoutError < StandardError
  def initialize(branch)
    super("Checkout failed for #{branch}")
  end
end

MERGE_QUEUE_PATH = File.join(Dir.pwd, 'merge-queue.yaml')
def merge_queue
  unless File.exist?(MERGE_QUEUE_PATH)
    Logger.error 'Merge queue not found, run "stacked init" first'
    exit 1
  end

  YAML.load_file(MERGE_QUEUE_PATH).compact
end

def parent_branch(branch_name)
  branch_index = merge_queue.index(branch_name)
  raise 'Branch not found' unless branch_index

  return merge_queue.at(branch_index - 1) if branch_index.positive?

  'main'
end

def keep_current_branch
  current_branch = `git branch --show-current`.strip
  yield
  `git checkout #{current_branch}`
end

def sync
  Logger.log 'Syncing stack (Make sure running this cmd on the branch which got an update)' do
    keep_current_branch do
      current_branch = `git branch --show-current`.strip
      `git checkout #{merge_queue.last}`
      raise CheckoutError, merge_queue.last unless $CHILD_STATUS.success?

      old_refs = merge_queue.drop(1).map do |branch|
        `git rev-parse --short #{branch}`.strip
      end

      `git rebase #{current_branch} --update-refs --autostash`
      raise RebaseError, current_branch unless $CHILD_STATUS.success?

      new_refs = merge_queue.drop(1).map do |branch|
        `git rev-parse --short #{branch}`.strip
      end

      merge_queue.drop(1).each_with_index do |branch, index|
        next if old_refs[index] == new_refs[index]

        Logger.log "Updated #{branch} from #{old_refs[index].accent} to #{new_refs[index].accent}"
      end

      `git push --force-with-lease origin #{merge_queue.drop(1).join(' ')}`

      Logger.success 'Done.'
    end
  end
rescue StandardError => e
  Logger.error "#{e.message}, aborting"
end

def sync_old
  Logger.log 'Syncing stack' do
    keep_current_branch do
      merge_queue.drop(2).each do |branch|
        `git checkout #{branch}`
        raise CheckoutError, branch unless $CHILD_STATUS.success?

        # if USE_ONTO
        # works only if the parent branch is not already pushed bc then local and remote (origin) are pointing to the same commit
        # possible solution: Retrieve old base in another way then relying on origin/parent_branch:
        # The following is a PoC to get the current base of the branch
        # git show $(git log parent_branch(branch)^..branch  --oneline --pretty=format:'%h' | tail -1)^ --pretty=format:'%h' --no-patch
        # But this is error-prone and not reliable
        # Therefore, use a normal rebase for syncing
        # `git rebase origin/#{parent_branch(branch)} --onto #{parent_branch(branch)} --autostash`
        # else
        `git rebase #{parent_branch(branch)} --autostash`
        # end

        raise RebaseError, parent_branch(branch) unless $CHILD_STATUS.success?
      end

      # TODO: Ensure writing a log to a file which contains the refs of all branches before pushing it
      # `git push --force-with-lease origin #{merge_queue.drop(1).join(' ')}`

      Logger.success 'Done.'
    end
  end
rescue StandardError => e
  Logger.error "#{e.message}, aborting"
end

def update
  keep_current_branch do
    Logger.log 'Rebasing stack to updated base branch' do
      base = merge_queue.at(0)
      `git fetch origin #{base}`

      if USE_ONTO
        first_branch = merge_queue.at(1)
        `git checkout #{first_branch}`
        raise CheckoutError, first_branch unless $CHILD_STATUS.success?

        old_ref = `git rev-parse --short #{first_branch}`.strip

        `git rebase #{base} --onto origin/#{base} --autostash`
        raise RebaseError, first_branch unless $CHILD_STATUS.success?

        new_ref = `git rev-parse --short #{first_branch}`.strip
        Logger.log "Updated #{first_branch} from #{old_ref.accent} to #{new_ref.accent}"
      end

      `git checkout #{base}`
      raise CheckoutError, base unless $CHILD_STATUS.success?

      `git merge --ff-only`
      raise FastForwardError, base unless $CHILD_STATUS.success?

      sync

      Logger.success 'Done.'
    end
  end
rescue StandardError => e
  Logger.error "#{e.message}, aborting"
end

# Implement better and smart deletion
# def delete
# updated_merge_queue = merge_queue.drop(1).dup

# if ARGV[1].nil?
# current_branch = `git branch --show-current`.strip
# updated_merge_queue.delete(current_branch)
# Logger.success "Deleted #{current_branch}"
# else
# updated_merge_queue.delete_at(ARGV[1].to_i)
# Logger.success "Deleted #{merge_queue.drop(1).at(ARGV[1].to_i)}"
# end

# File.write(MERGE_QUEUE_PATH, ['main', *updated_merge_queue].to_yaml)
# end

def init
  current_branch = `git branch --show-current`.strip
  queue = ['main']
  queue.push(current_branch) if current_branch != 'main'
  File.write(MERGE_QUEUE_PATH, queue.to_yaml)
end

def branch(name)
  `git checkout -b #{name}`
  File.write(MERGE_QUEUE_PATH, [*merge_queue, name].to_yaml)
end

def pr
  current_branch = `git branch --show-current`.strip
  `git push --set-upstream origin #{current_branch}`
  `gh pr create --web --base #{parent_branch(current_branch)}`
end

# index: absolute number (1, 2) or relative number (-1, +2)
# if ommitted, a fuzzy search via fzf is started
def checkout(index = nil)
  queue_without_base = merge_queue.drop(1)

  if index.nil?
    branches_list = queue_without_base.map { |x| "\"#{x}\"" }.join(' ')
    branch = `items=(#{branches_list}); printf "%s\n" "${items[@]}" | fzf`
    `git checkout #{branch}`
    return
  end

  if index.start_with?(/\+|-/)
    current_branch = `git branch --show-current`.strip
    current_branch_index = queue_without_base.find_index(current_branch)
    `git checkout #{queue_without_base.at(current_branch_index + index.to_i)}`
  else
    `git checkout #{queue_without_base.at(index.to_i)}`
  end
end

def parent
  current_branch = `git branch --show-current`.strip
  puts parent_branch(current_branch)
end

def open
  cmd = OS.linux? ? 'xdg-open' : 'open'
  remote = `git remote get-url origin`.strip
  org_and_repo = remote[/:(.*)\.git/, 1]

  merge_queue.drop(1).each do |branch|
    `#{cmd} https://github.com/#{org_and_repo}/pull/#{branch}`
  end
end

def run
  command = ARGV[0]

  if %w[init branch pr parent open update sync].include?(command)
    send(command, *ARGV[1..])
  elsif command == '-'
    checkout('-1')
  elsif command == '+'
    checkout('+1')
  else
    checkout(ARGV[0])
  end
end

Logger.init
run
